from __future__ import annotations

import json
from pathlib import Path
import textwrap

ROOT = Path(__file__).resolve().parents[1]
RECURSION_DIR = ROOT / "Recursion"
OUTPUT = RECURSION_DIR / "Recursion_Problems.ipynb"

cells: list[dict] = []


def to_source_lines(text: str) -> list[str]:
    return [line + "\n" for line in text.splitlines()]


def add_markdown(text: str) -> None:
    text = textwrap.dedent(text).strip("\n")
    cells.append(
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": to_source_lines(text),
        }
    )


def add_code_from(path: Path) -> None:
    source = path.read_text()
    cells.append(
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {"language": "cpp"},
            "outputs": [],
            "source": to_source_lines(source),
        }
    )


def add_problem(problem: dict) -> None:
    approach_lines = "\n".join(f"* {line}" for line in problem["approach"])
    text = f"""### {problem['title']}\n\n"""
    text += f"**Problem statement:** {problem['statement']}\n\n"
    text += "**Example:**\n"
    text += "```\n" + problem["example"].strip("\n") + "\n```\n"
    text += f"**Explanation:** {problem['explanation']}\n\n"
    text += "**Approach highlights:**\n"
    text += approach_lines + "\n\n"
    text += (
        f"**Complexity:** Time {problem['time_complexity']}, "
        f"Space {problem['space_complexity']}."
    )
    add_markdown(text)
    add_code_from(RECURSION_DIR / problem["file"])


add_markdown(
    """
# Recursion and Backtracking Interview Workbook
"""
)
add_markdown(
    """
This notebook collects every recursion and backtracking challenge from the repository. Each section lays out the interview prompt,
provides a small example, summarises the recursive insight, and then embeds the original C++ implementation so you can review
the reasoning alongside the working code.
"""
)
add_markdown(
    """
## Recursion primer

- Identify a base case that terminates the recursion without further calls.
- Define the transition that shrinks the problemâ€”usually by moving to the next index, value, or cell.
- On backtracking problems, undo any modifications before exploring another branch so the shared state stays correct.
- Analyse the branching factor and recursion depth to estimate the complexity and avoid exponential blow-ups when possible.
"""
)

categories: list[dict] = [
    {
        "title": "Recursive Building Blocks",
        "intro": (
            "Start with the classic include/exclude templates that power most recursion and backtracking solutions. These"
            " exercises build intuition for managing base cases and state copies."
        ),
        "problems": [
            {
                "title": "Print All Subsequences of an Array",
                "file": "Recursion_on_Subsequences_Printing_them.cpp",
                "statement": (
                    "Given an array of integers, print every possible subsequence, including the empty subsequence, in the"
                    " order they are generated by the recursion."
                ),
                "example": "nums = [3, 1]\nOutput:\n[]\n[1]\n[3]\n[3, 1]",
                "explanation": (
                    "For each position you either include the element or skip it, leading to 2^n total subsequences."
                ),
                "approach": [
                    "Recurse on the current index with two choices: exclude it or push it to the working container.",
                    "When the index reaches the array length, print the accumulated subsequence and return.",
                    "Backtrack by removing the last element before exploring the branch that excludes it."
                ],
                "time_complexity": "O(2^n * n) to print every subsequence",
                "space_complexity": "O(n) recursion depth",
            },
            {
                "title": "Target Sum Subsequences (All Patterns)",
                "file": "All_Kind_of_Patterns_in_Recursion.cpp",
                "statement": (
                    "Given n integers and a target sum k, print all subsequences whose sum equals k and also support"
                    " checking whether any solution exists or how many such subsequences there are."
                ),
                "example": "nums = [1, 2, 1], k = 2\nOutput:\n1 1\n2",
                "explanation": (
                    "The recursion branches on picking or skipping each value, tracking the running sum so only"
                    " subsequences that hit k are recorded."
                ),
                "approach": [
                    "Carry a working vector and the running sum while iterating over indices.",
                    "When the running sum reaches k at the end of the array, either print the subsequence or increment a counter.",
                    "Use backtracking (pop the last value and revert the sum) before exploring the alternative branch."
                ],
                "time_complexity": "O(2^n) branches in the worst case",
                "space_complexity": "O(n) for the recursion stack",
            },
            {
                "title": "Enumerate All Subset Sums",
                "file": "Subset_sum.cpp",
                "statement": (
                    "List every achievable subset sum from the given array and output them in sorted order."
                ),
                "example": "nums = [1, 2, 3]\nOutput: 0 1 2 3 4 5 6",
                "explanation": (
                    "The recursion accumulates the sum along each include/exclude branch, storing results in a set"
                    " to avoid duplicates before printing."
                ),
                "approach": [
                    "Maintain the current sum while branching on including or skipping each array element.",
                    "Insert every terminal sum into an ordered container so outputs stay sorted.",
                    "After exploring the include branch, subtract the element to restore the running sum for the exclude branch."
                ],
                "time_complexity": "O(2^n) subsets to evaluate",
                "space_complexity": "O(n) recursion depth plus the set of sums",
            },
        ],
    },
    {
        "title": "Combination Search and Partitioning",
        "intro": (
            "These problems extend the basic template to build combinations that satisfy constraints on sums or string"
            " partitions."
        ),
        "problems": [
            {
                "title": "Combination Sum with Unlimited Picks",
                "file": "Combination_Sum.cpp",
                "statement": (
                    "Given distinct candidate numbers and a target, print every unique combination where the chosen numbers"
                    " add up to the target. You may reuse each candidate unlimited times."
                ),
                "example": "candidates = [2, 3, 6, 7], target = 7\nOutput:\n2 2 3\n7",
                "explanation": (
                    "At each index the recursion can either reuse the current candidate (keeping the index unchanged)"
                    " or move on, ensuring all combinations are generated without duplicates."
                ),
                "approach": [
                    "Sort or iterate the candidates consistently so duplicate combinations collapse naturally.",
                    "If the current value does not exceed the remaining target, include it and continue with the same index.",
                    "Otherwise, advance to the next candidate to explore alternative combinations."
                ],
                "time_complexity": "O(2^n) in the worst case due to branching",
                "space_complexity": "O(target depth) for the recursion path",
            },
            {
                "title": "Palindromic Partitioning of a String",
                "file": "Palindromic_Partition.cpp",
                "statement": (
                    "Split the input string into all possible lists of substrings such that every substring is a palindrome."
                ),
                "example": "s = 'aab'\nOutput:\n['a', 'a', 'b']\n['aa', 'b']",
                "explanation": (
                    "Every cut point is explored recursively, but only palindromic prefixes lead to deeper calls,"
                    " ensuring each partition is valid."
                ),
                "approach": [
                    "Iterate over end positions starting from the current index to generate candidate prefixes.",
                    "Use a helper to verify whether the prefix is a palindrome before recursing deeper.",
                    "Push the substring to the current partition, recurse, and then pop it to backtrack for the next cut."
                ],
                "time_complexity": "O(n * 2^n) exploring all partitions",
                "space_complexity": "O(n) recursion depth",
            },
        ],
    },
    {
        "title": "Permutation Toolset",
        "intro": (
            "Once comfortable with include/exclude recursion, generate permutations directly either exhaustively or"
            " by targeting the k-th ordering."
        ),
        "problems": [
            {
                "title": "Generate All Permutations",
                "file": "Permutation_of_String.cpp",
                "statement": (
                    "Print every distinct permutation of the provided numbers. The program demonstrates both frequency-array"
                    " and in-place swapping approaches."
                ),
                "example": "nums = [1, 2, 3]\nOutput:\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1",
                "explanation": (
                    "Swapping the current index with every candidate position enumerates all factorial orderings"
                    " without extra allocations once duplicates are handled."
                ),
                "approach": [
                    "Use a frequency array or boolean vector to track which positions are already chosen in the permutation.",
                    "Alternatively, swap the current index with each candidate index, recurse, and then swap back to restore the array.",
                    "Collect or print the permutation when the working vector reaches the input length."
                ],
                "time_complexity": "O(n! * n) to print all permutations",
                "space_complexity": "O(n) recursion depth",
            },
            {
                "title": "K-th Permutation Sequence",
                "file": "kth_Permutation_Sequence.cpp",
                "statement": (
                    "Given n and k, output the k-th permutation (1-indexed) of the numbers 1 through n in lexicographic order."
                ),
                "example": "n = 3, k = 4\nOutput: 2 3 1",
                "explanation": (
                    "Factorials quantify how many permutations start with each prefix, so repeatedly selecting the"
                    " correct block locates the desired ordering without exploring all permutations."
                ),
                "approach": [
                    "Precompute (n-1)! and maintain a list of the remaining numbers.",
                    "Convert k-1 into factorial number system digits to pick each next element.",
                    "Erase the used number from the list and shrink the factorial multiplier as the list shortens."
                ],
                "time_complexity": "O(n^2)",
                "space_complexity": "O(n) for the list of remaining digits",
            },
        ],
    },
    {
        "title": "Backtracking Through Mazes",
        "intro": (
            "Maze problems illustrate how backtracking explores spatial branches while marking visited cells to prevent"
            " cycles."
        ),
        "problems": [
            {
                "title": "Rat in a Maze (Path Matrix)",
                "file": "BackTracking/BackTracking_1.cpp",
                "statement": (
                    "Given an m x n grid where 1 denotes an open cell and 0 a blocked one, find a path from the top-left"
                    " corner to the bottom-right corner moving only down or right, and print the path as a matrix of 0s"
                    " and 1s."
                ),
                "example": (
                    "maze = [[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 1]]\n"
                    "Output path:\n1 0 0 0\n1 1 0 0\n0 1 0 0\n0 1 1 1"
                ),
                "explanation": (
                    "The recursion marks the current cell, tries moving forward (down or right), and backtracks if a branch"
                    " dead-ends so another route can be explored."
                ),
                "approach": [
                    "Check whether the next cell is inside bounds, open, and not already part of the path before moving.",
                    "Mark the cell as part of the solution matrix, recurse deeper, and return true as soon as the destination is reached.",
                    "If both moves fail, reset the cell to 0 to backtrack and continue searching."
                ],
                "time_complexity": "O(2^{m+n}) in the worst case",
                "space_complexity": "O(mn) for the recursion and solution matrices",
            },
            {
                "title": "Rat in a Maze (All Move Directions)",
                "file": "BackTracking/Rat_In_Maze.cpp",
                "statement": (
                    "For an n x n maze with open cells marked by 1, enumerate all paths from the origin to the destination"
                    " using moves down, left, right, and up without revisiting a cell."
                ),
                "example": (
                    "maze = [[1, 0, 0, 0], [1, 1, 0, 1], [1, 1, 0, 0], [0, 1, 1, 1]]\n"
                    "Output paths: DDRDRR, DRDDRR"
                ),
                "explanation": (
                    "Exploring four directions requires tracking visited cells so paths do not loop; each successful"
                    " path yields a string of move characters."
                ),
                "approach": [
                    "Keep a visited matrix that is toggled before descending into a neighbouring cell and cleared on return.",
                    "Append the move character ('D', 'L', 'R', 'U') to the working string to record the path.",
                    "When the destination is reached, push the completed move sequence into the answer list."
                ],
                "time_complexity": "O(4^{n^2}) in the worst case",
                "space_complexity": "O(n^2) for visited state",
            },
            {
                "title": "Sudoku Solver",
                "file": "BackTracking/Sudoku_Solver.cpp",
                "statement": (
                    "Solve a 9x9 Sudoku puzzle by filling empty cells ('.') so every row, column, and 3x3 subgrid contains"
                    " the digits 1 through 9 exactly once."
                ),
                "example": (
                    "Input board (rows concatenated):\n"
                    "53..7....\n6..195...\n.98....6.\n8...6...3\n4..8.3..1\n7...2...6\n.6....28.\n...419..5\n....8..79\n"
                    "Output row: 534678912 (and similarly solved rows)"
                ),
                "explanation": (
                    "The solver tests candidate digits for each empty cell, ensuring the Sudoku constraints remain satisfied"
                    " before recursing to the next cell."
                ),
                "approach": [
                    "Scan the grid to find the next empty cell; if none remain the puzzle is solved.",
                    "Try each digit '1' through '9' and validate it against the row, column, and 3x3 box constraints.",
                    "Place a valid digit, recurse, and revert to '.' if deeper recursion fails so another choice can be tried."
                ],
                "time_complexity": "O(9^{empty}) in the worst case",
                "space_complexity": "O(1) extra beyond the board",
            },
        ],
    },
    {
        "title": "Constraint Satisfaction on Boards",
        "intro": (
            "Placing queens demonstrates how backtracking navigates combinatorial search spaces under mutual exclusion constraints."
        ),
        "problems": [
            {
                "title": "N-Queens (Matrix Representation)",
                "file": "BackTracking/BackTracking_2.cpp",
                "statement": (
                    "Place n queens on an n x n chessboard so that no two queens attack each other and print one solution"
                    " as a matrix of 0s and 1s."
                ),
                "example": (
                    "n = 4\nOutput matrix:\n0 1 0 0\n0 0 0 1\n1 0 0 0\n0 0 1 0"
                ),
                "explanation": (
                    "The solver attempts to place a queen row by row, checking the column and both diagonals before committing"
                    " to a position."
                ),
                "approach": [
                    "Iterate columns in the current row and test whether the position is safe by scanning upward columns and diagonals.",
                    "Place a queen, recurse to the next row, and immediately return true if the recursion finds a solution.",
                    "Remove the queen when backtracking so other columns can be tested."
                ],
                "time_complexity": "O(n!)",
                "space_complexity": "O(n^2) for the board",
            },
            {
                "title": "N-Queens (Board Layout)",
                "file": "BackTracking/N_Queen_Problem.cpp",
                "statement": (
                    "Print an arrangement of n queens using a character board where 'Q' marks a queen and '.' marks an empty cell."
                ),
                "example": (
                    "n = 4\nOutput board:\n. Q . .\n. . . Q\nQ . . .\n. . Q ."
                ),
                "explanation": (
                    "This variant stores the board as strings and prints every valid configuration found during recursion."
                ),
                "approach": [
                    "For each column in the current row, verify no other queen threatens it via the left row, upper-left, or lower-left diagonals.",
                    "Mark the column with 'Q', recurse on the next column, and print the board when all queens are placed.",
                    "Revert the placement to '.' to explore alternative column choices."
                ],
                "time_complexity": "O(n!)",
                "space_complexity": "O(n^2) to store the board",
            },
        ],
    },
]

for section in categories:
    add_markdown(f"## {section['title']}")
    if section.get("intro"):
        add_markdown(section["intro"])
    for problem in section["problems"]:
        add_problem(problem)

nb = {
    "cells": cells,
    "metadata": {},
    "nbformat": 4,
    "nbformat_minor": 5,
}

OUTPUT.write_text(json.dumps(nb, indent=2))
