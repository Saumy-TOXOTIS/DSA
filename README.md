# 🚀 DSA Practice Hub | Saumy's Code Playground 🚀

Hey everyone! 👋 Welcome to my personal space for mastering Data Structures and Algorithms. This repository is my journey of solving problems, implementing algorithms from scratch, and building a strong foundation for competitive programming and technical interviews.

---

## 🆕 Latest Additions & Highlights

Over time the repository has grown into a complete revision companion. The newest resources include:

* 📓 **Topic-wise Workbooks** – Rich `.ipynb` notebooks for Arrays, Binary Search, Bit Manipulation, Dynamic Programming, Graphs, Greedy, Recursion, Sorting Algorithms, Stack & Queue, and Two Pointers & Sliding Window. Each notebook captures the problem statement, sample I/O, approach discussion, complexity breakdown, and the linked C++ implementation.
* 🤖 **Notebook Generators** – Python helpers in `scripts/` that rebuild every workbook automatically so updates to source files stay in sync with the study material.
* 🧩 **Fresh Implementations** – New solutions such as `Product_of_Array_Except_Itself.cpp`, the reworked `Implement_Min_Stack.cpp`, and `Stock_Span_Problem.cpp` complement the documentation with fully functioning references.

---

## 📚 Topics Covered

This repository is organized by topics. Here's what you'll find inside:

* 📂 **Arrays/Algorithms** – Core array manipulations, fundamental algorithms, and the `Arrays_Problems.ipynb` workbook.
* 🔍 **Binary Search** – Classical and advanced search patterns with `Binary_Search_Problems.ipynb`.
* 🧠 **Dynamic Programming** – Substructure & overlapping subproblems covered in `Dynamic_Programming_Problems.ipynb`.
* 🕸️ **Graph** – Traversals, shortest paths, and more in `Graph_Problems.ipynb`.
* 💡 **Greedy** – Strategy-first solutions alongside `Greedy_Problems.ipynb`.
* 🔄 **Recursion** – Backtracking templates and `Recursion_Problems.ipynb`.
* 📊 **Sorting Algorithms** – Classic and specialized techniques plus `Sorting_Algorithms_Problems.ipynb`.
* 📦 **Stack and Queue** – Utility structures, `Stack_and_Queue_Problems.ipynb`, and enhanced implementations for Min Stack and Stock Span.
* ⚡ **Bit Manipulation** – Tricks & patterns detailed in `Bit_Manipulation_Problems.ipynb`.
* 👉 **Two Pointers & Sliding Window** – Optimised linear scans with `Two_Pointers_and_Sliding_Window_Problems.ipynb`.
* 🌳 **Trie** – A dedicated folder for trie-based challenges (notebook coming soon!).
* 🌲 **Tree** – Classic tree problems and traversals.

---

## 📁 Repository Structure

The structure is simple and easy to navigate:

```
DSA/
├── Arrays/
│   ├── Algorithms/
│   └── Arrays_Problems.ipynb
├── Binary Search/
│   └── Binary_Search_Problems.ipynb
├── Bit Manipulation/
│   └── Bit_Manipulation_Problems.ipynb
├── Dynamic Programming/
│   └── Dynamic_Programming_Problems.ipynb
├── Graph/
│   └── Graph_Problems.ipynb
├── Greedy/
│   └── Greedy_Problems.ipynb
├── Recursion/
│   └── Recursion_Problems.ipynb
├── Sorting Algorithms/
│   └── Sorting_Algorithms_Problems.ipynb
├── Stack and Queue/
│   ├── Implement_Min_Stack.cpp
│   ├── Stack_and_Queue_Problems.ipynb
│   └── Stock_Span_Problem.cpp
├── Tree/
├── Trie/
├── Two Pointers and SlidingWindow/
│   └── Two_Pointers_and_Sliding_Window_Problems.ipynb
└── scripts/
    ├── generate_arrays_notebook.py
    ├── generate_binary_search_notebook.py
    ├── generate_bit_manipulation_notebook.py
    ├── generate_graph_notebook.py
    ├── generate_greedy_notebook.py
    ├── generate_recursion_notebook.py
    ├── generate_sorting_notebook.py
    ├── generate_stack_queue_notebook.py
    └── generate_two_pointers_notebook.py
```

Each folder contains well-commented code, and every workbook embeds the corresponding C++ source for quick revision.

---

## 📓 Interactive Study Notebooks

| Topic | Notebook | Quick Overview |
| --- | --- | --- |
| Arrays | `Arrays/Arrays_Problems.ipynb` | Sliding windows, prefix tricks, constructive builds, Kadane variations, and more. |
| Binary Search | `Binary Search/Binary_Search_Problems.ipynb` | Fundamentals, rotated arrays, 2D grids, and answer-space feasibility checks. |
| Bit Manipulation | `Bit Manipulation/Bit_Manipulation_Problems.ipynb` | XOR patterns, arithmetic hacks, set-bit DP, and bitset number theory. |
| Dynamic Programming | `Dynamic Programming/Dynamic_Programming_Problems.ipynb` | 1D/2D DP, subsequences, partitions, strings, and optimisation strategies. |
| Graph | `Graph/Graph_Problems.ipynb` | Traversals, shortest paths, MSTs, topological sorting, and miscellaneous graph puzzles. |
| Greedy | `Greedy/Greedy_Problems.ipynb` | Interval scheduling, job sequencing, reachability, and classic greedy heuristics. |
| Recursion | `Recursion/Recursion_Problems.ipynb` | Backtracking templates, DFS explorations, and combinatorial search problems. |
| Sorting | `Sorting Algorithms/Sorting_Algorithms_Problems.ipynb` | Comparison sorts, divide-and-conquer, counting/radix styles, and stability insights. |
| Stack & Queue | `Stack and Queue/Stack_and_Queue_Problems.ipynb` | Monotonic stack routines, queue simulations, Min Stack, and Stock Span walkthroughs. |
| Two Pointers & Sliding Window | `Two Pointers and SlidingWindow/Two_Pointers_and_Sliding_Window_Problems.ipynb` | Dual-pointer patterns, window resizing, and hybrid hashing strategies. |

---

## 🛠️ Notebook Generators

Most notebooks are reproducible from structured metadata so that statements, explanations, and source files stay aligned. To refresh any workbook, run:

```bash
python scripts/generate_<topic>_notebook.py
```

Replace `<topic>` with one of:

`arrays`, `binary_search`, `bit_manipulation`, `graph`, `greedy`, `recursion`, `sorting`, `stack_queue`, or `two_pointers`.

> 💡 Tip: Keep the C++ solutions up to date before regenerating—the scripts embed the latest source automatically.

---

## 🛠️ How to Use

Clone the repository to your local machine to test and learn from the code or open the notebooks directly in Jupyter/VS Code:

```bash
git clone https://github.com/Saumy-TOXOTIS/DSA.git
```

Explore the folders, run the code, open the notebooks, and see how different problems are solved!

---

## 🤝 Contributing

While this is a personal practice repository, I'm always open to suggestions and improvements! If you have a more optimal solution or want to add a new problem:

1. **Fork** the repository.
2. Create a new **branch** (`git checkout -b feature/AmazingNewProblem`).
3. **Commit** your changes (`git commit -m 'Add: Solution for XYZ problem'`).
4. **Push** to the branch (`git push origin feature/AmazingNewProblem`).
5. Open a **Pull Request**.

Feel free to raise an issue if you find a bug or have a question!

---

### Happy Coding! 💻
